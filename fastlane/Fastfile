# fastlane/Fastfile
# Beekeepr - Single app (one env) build + distribution
#
# iOS:
#   - Prebuild iOS (Expo)
#   - Pods install
#   - Build IPA (dynamic export options; no ExportOptions.plist needed)
#   - Validate ASC API key (hits App Store Connect)
#   - Upload to TestFlight
#   - Optional: Submit for App Store review
#
# Android:
#   - Prebuild Android (Expo)
#   - Build AAB
#   - Upload to Google Play (track)
#
# Required CI env vars / GitHub Secrets:
# iOS (App Store Connect API key):
#   ASC_KEY_ID
#   ASC_ISSUER_ID
#   ASC_KEY_P8
#   ASC_KEY_P8_BASE64   ("true" if ASC_KEY_P8 is base64)
#   IOS_BUNDLE_ID
#
# Optional iOS:
#   IOS_TEAM_ID         (only if signing/team selection is needed)
#   IOS_SCHEME          (defaults to "Beekeepr")
#   IOS_WORKSPACE       (defaults to "../ios/<scheme>.xcworkspace")
#   IOS_EXPORT_METHOD   (app-store|ad-hoc|enterprise|development) default "app-store"
#
# Android (Google Play service account):
#   PLAY_JSON_KEY_DATA  (service account JSON contents) OR PLAY_JSON_KEY_PATH
#
# Optional Android:
#   PLAY_TRACK          (internal|closed|open|production) default "internal"
#   RELEASE_NOTES       (string)
#
# Optional deliver/supply flags:
#   SKIP_METADATA=true
#   SKIP_SCREENSHOTS=true
#   SKIP_IMAGES=true
#
# Local dev:
#   fastlane/.env.local (gitignored) can hold the env vars above.

require "fileutils"

opt_out_usage
default_platform(:ios)

APP_NAME = "Beekeepr"

SCHEME    = ENV["IOS_SCHEME"] || "Beekeepr"
WORKSPACE = ENV["IOS_WORKSPACE"] || "../ios/#{SCHEME}.xcworkspace"

BUILD_DIR   = "../build"
IOS_IPA     = "#{BUILD_DIR}/#{APP_NAME}.ipa"
ANDROID_AAB = "#{BUILD_DIR}/#{APP_NAME}.aab"

def project_root
  File.expand_path("..", __dir__)
end

def ensure_build_dir!
  FileUtils.mkdir_p(File.expand_path(BUILD_DIR, __dir__))
end

def expo_prebuild(platform)
  sh("cd #{project_root} && npx expo prebuild --platform #{platform} --clean")
end

def ensure_ios_bundle_id!
  bundle_id = ENV["IOS_BUNDLE_ID"].to_s.strip
  UI.user_error!("Missing IOS_BUNDLE_ID (e.g. com.beekeepr.app)") if bundle_id.empty?
  bundle_id
end

def setup_asc_api_key!
  UI.user_error!("Missing ASC_KEY_ID") if ENV["ASC_KEY_ID"].to_s.strip.empty?
  UI.user_error!("Missing ASC_ISSUER_ID") if ENV["ASC_ISSUER_ID"].to_s.strip.empty?

  key_content =
    if ENV["ASC_KEY_P8"].to_s.strip.length > 0
      ENV["ASC_KEY_P8"]
    else
      `security find-generic-password -s ASC_API_KEY_P8 -w`.strip
    end

  UI.user_error!("No ASC private key found (env or keychain)") if key_content.empty?

  app_store_connect_api_key(
    key_id: ENV["ASC_KEY_ID"],
    issuer_id: ENV["ASC_ISSUER_ID"],
    key_content: key_content,
    is_key_content_base64: ENV["ASC_KEY_P8_BASE64"] == "true"
  )
end


def resolve_play_json_key_path!
  return ENV["PLAY_JSON_KEY_PATH"] if ENV["PLAY_JSON_KEY_PATH"].to_s.strip.length > 0

  json_data = ENV["PLAY_JSON_KEY_DATA"].to_s
  UI.user_error!("Missing PLAY_JSON_KEY_PATH or PLAY_JSON_KEY_DATA") if json_data.strip.length == 0

  tmp_dir = File.join(__dir__, ".tmp")
  FileUtils.mkdir_p(tmp_dir)

  path = File.join(tmp_dir, "play-service-account.json")
  File.write(path, json_data)
  path
end

# ============================
# iOS
# ============================
platform :ios do
  desc "Check fastlane setup"
  lane :doctor do
    sh("ruby -v")
    sh("bundle exec fastlane -v")
    sh("xcodebuild -version")
  end

  desc "Validate App Store Connect API key"
  lane :validate_asc do
    setup_asc_api_key!  # don't capture return value

    require "spaceship"
    apps = Spaceship::ConnectAPI::App.all

    UI.success("ASC key validated âœ… (apps accessible: #{apps.length})")
    UI.message("Using bundle id: #{ensure_ios_bundle_id!}")
  end

  desc "Build iOS IPA"
  lane :build do
    ensure_build_dir!
    ensure_ios_bundle_id!

    UI.message("Building iOS (#{APP_NAME})")

    expo_prebuild("ios")

    cocoapods(
      podfile: "ios/Podfile",
      use_bundle_exec: true
    )

    export_method = (ENV["IOS_EXPORT_METHOD"] || "app-store").strip

    gym(
      workspace: WORKSPACE,
      scheme: SCHEME,
      configuration: "Release",
      clean: true,
      export_options: {
        method: export_method,
        uploadSymbols: true,
        uploadBitcode: false
      },
      output_directory: BUILD_DIR,
      output_name: "#{APP_NAME}.ipa",
      export_team_id: (ENV["IOS_TEAM_ID"].to_s.strip.length > 0 ? ENV["IOS_TEAM_ID"].to_s.strip : nil)
    )

    UI.message("Built IPA: #{IOS_IPA}")
  end

  desc "Upload IPA to TestFlight"
  lane :upload_testflight do
    UI.user_error!("Missing IPA at #{IOS_IPA}. Run `fastlane ios build` first.") unless File.exist?(IOS_IPA)

    setup_asc_api_key!

    pilot(
      ipa: IOS_IPA,
      app_identifier: ensure_ios_bundle_id!,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Submit to App Store review"
  lane :submit_review do
    setup_asc_api_key!

    deliver(
      app_identifier: ensure_ios_bundle_id!,
      force: true,
      submit_for_review: true,
      automatic_release: false,
      skip_screenshots: ENV["SKIP_SCREENSHOTS"] == "true",
      skip_metadata: ENV["SKIP_METADATA"] == "true"
    )
  end
end

# ============================
# Android
# ============================
platform :android do
  desc "Build Android AAB"
  lane :build do
    ensure_build_dir!
    UI.message("Building Android (#{APP_NAME})")

    expo_prebuild("android")

    gradle(
      project_dir: "../android",
      task: "bundleRelease"
    )

    sh("cp ../android/app/build/outputs/bundle/release/*.aab #{ANDROID_AAB}")
    UI.message("Built AAB: #{ANDROID_AAB}")
  end

  desc "Upload AAB to Google Play"
  lane :play do
    UI.user_error!("Missing AAB at #{ANDROID_AAB}. Run `fastlane android build` first.") unless File.exist?(ANDROID_AAB)

    supply(
      aab: ANDROID_AAB,
      track: (ENV["PLAY_TRACK"] || "internal").strip,
      json_key: resolve_play_json_key_path!,
      release_status: "draft",
      changelog: ENV["RELEASE_NOTES"],
      skip_upload_metadata: ENV["SKIP_METADATA"] == "true",
      skip_upload_images: ENV["SKIP_IMAGES"] == "true",
      skip_upload_screenshots: ENV["SKIP_SCREENSHOTS"] == "true"
    )
  end
end
